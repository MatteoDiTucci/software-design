<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Compendium of Software Design</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A summary with sources of what contributes to good software design">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="passes-all-tests/introduction.html"><strong aria-hidden="true">2.</strong> It passes all tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="passes-all-tests/test-pyramid.html"><strong aria-hidden="true">2.1.</strong> Test pyramid</a></li><li class="chapter-item expanded "><a href="passes-all-tests/if-testing-is-hard-inject.html"><strong aria-hidden="true">2.2.</strong> If testing is hard, inject what you need to verify</a></li><li class="chapter-item expanded "><a href="passes-all-tests/test-doubles.html"><strong aria-hidden="true">2.3.</strong> Test doubles</a></li><li class="chapter-item expanded "><a href="passes-all-tests/test-driven-development.html"><strong aria-hidden="true">2.4.</strong> Test driven development</a></li><li class="chapter-item expanded "><a href="passes-all-tests/test-coverage-is-not-enough.html"><strong aria-hidden="true">2.5.</strong> Test coverage is not enough</a></li><li class="chapter-item expanded "><a href="passes-all-tests/tests-must-be-reproducible.html"><strong aria-hidden="true">2.6.</strong> Tests must be reproducible</a></li><li class="chapter-item expanded "><a href="passes-all-tests/no-production-code-constants-in-tests.html"><strong aria-hidden="true">2.7.</strong> No production code constants in tests</a></li><li class="chapter-item expanded "><a href="passes-all-tests/do-not-test-external-libraries.html"><strong aria-hidden="true">2.8.</strong> Do not test external libraries üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="passes-all-tests/expand-and-contract.html"><strong aria-hidden="true">2.9.</strong> Expand and contract</a></li><li class="chapter-item expanded "><a href="passes-all-tests/performance-tests.html"><strong aria-hidden="true">2.10.</strong> Performance tests üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="passes-all-tests/how-to-test-ui.html"><strong aria-hidden="true">2.11.</strong> How to test UI üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="passes-all-tests/linting.html"><strong aria-hidden="true">2.12.</strong> Linting üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="passes-all-tests/test-for-production.html"><strong aria-hidden="true">2.13.</strong> Test for production</a></li><li class="chapter-item expanded "><a href="passes-all-tests/tests-for-distributed-systems.html"><strong aria-hidden="true">2.14.</strong> Tests for distributed systems</a></li><li class="chapter-item expanded "><a href="passes-all-tests/test-infrastructure.html"><strong aria-hidden="true">2.15.</strong> Test infrastructure üèóÔ∏è</a></li></ol></li><li class="chapter-item expanded "><a href="expresses-intent/introduction.html"><strong aria-hidden="true">3.</strong> It expresses intent</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="expresses-intent/naming.html"><strong aria-hidden="true">3.1.</strong> Naming</a></li><li class="chapter-item expanded "><a href="expresses-intent/deep-and-narrow-classes.html"><strong aria-hidden="true">3.2.</strong> Deep and narrow classes</a></li><li class="chapter-item expanded "><a href="expresses-intent/immutability.html"><strong aria-hidden="true">3.3.</strong> Immutability</a></li><li class="chapter-item expanded "><a href="expresses-intent/generalise-edge-cases.html"><strong aria-hidden="true">3.4.</strong> Generalise edge casesÔ∏è</a></li><li class="chapter-item expanded "><a href="expresses-intent/small-classes-and-short-methods.html"><strong aria-hidden="true">3.5.</strong> Small classes and short methods üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="expresses-intent/usually-composition-is-better-than-inheritance.html"><strong aria-hidden="true">3.6.</strong> Usually composition is better than inheritance</a></li><li class="chapter-item expanded "><a href="expresses-intent/test-naming.html"><strong aria-hidden="true">3.7.</strong> Test naming üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="expresses-intent/comment-the-why.html"><strong aria-hidden="true">3.8.</strong> Comment the why üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="expresses-intent/visual-indentation.html"><strong aria-hidden="true">3.9.</strong> Visual indentation üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="expresses-intent/folder-structure.html"><strong aria-hidden="true">3.10.</strong> Folder structure üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="expresses-intent/wishful-thinking.html"><strong aria-hidden="true">3.11.</strong> Wishful thinking üèóÔ∏è</a></li></ol></li><li class="chapter-item expanded "><a href="does-not-repeat-itself/introduction.html"><strong aria-hidden="true">4.</strong> It does not repeat itself</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="does-not-repeat-itself/one-single-authoritative-representation.html"><strong aria-hidden="true">4.1.</strong> One single authoritative knowledge representation</a></li><li class="chapter-item expanded "><a href="does-not-repeat-itself/do-not-abstract-by-visual-pattern-matching.html"><strong aria-hidden="true">4.2.</strong> Do not abstract by visual pattern matching</a></li><li class="chapter-item expanded "><a href="does-not-repeat-itself/open-closed-principle.html"><strong aria-hidden="true">4.3.</strong> Open-closed principleÔ∏è</a></li><li class="chapter-item expanded "><a href="does-not-repeat-itself/dependency-inversion-principle.html"><strong aria-hidden="true">4.4.</strong> Dependency inversion principle</a></li><li class="chapter-item expanded "><a href="does-not-repeat-itself/information-hiding.html"><strong aria-hidden="true">4.5.</strong> Information hidingÔ∏è</a></li><li class="chapter-item expanded "><a href="does-not-repeat-itself/wrap-external-libraries-into-custom-classes.html"><strong aria-hidden="true">4.6.</strong> Wrap external libraries into custom classesÔ∏è</a></li><li class="chapter-item expanded "><a href="does-not-repeat-itself/polymorphism.html"><strong aria-hidden="true">4.7.</strong> Polymorphism üèóÔ∏è</a></li><li class="chapter-item expanded "><a href="expresses-intent/single-responsibility-principle.html"><strong aria-hidden="true">4.8.</strong> Single responsibility principle üèóÔ∏è</a></li></ol></li><li class="chapter-item expanded "><a href="does-not-contain-superfluous-parts/introduction.html"><strong aria-hidden="true">5.</strong> It does not contain superfluous parts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="does-not-contain-superfluous-parts/you-are-not-going-to-need-it.html"><strong aria-hidden="true">5.1.</strong> Does not contain superfluous parts</a></li><li class="chapter-item expanded "><a href="does-not-contain-superfluous-parts/clarify-what-is-superfluous.html"><strong aria-hidden="true">5.2.</strong> Clarify what is superfluous</a></li><li class="chapter-item expanded "><a href="does-not-contain-superfluous-parts/do-not-abuse-design-patterns.html"><strong aria-hidden="true">5.3.</strong> Do not abuse design patterns</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A Compendium of Software Design</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<h3><a class="header" href="#why-read-this-book" id="why-read-this-book">Why read this book</a></h3>
<p>Software design is a craft not a science. To master it you cannot just study a book that explains comprehensively all the theory behind it.
You have to read the literature of many great developers, looking for advices that repeat: that's what is currently considered good software design.
However, the literature is vast and it takes much time to get the big picture out of single sources.
This book makes three promises:</p>
<ul>
<li>to be a compendium of what contributes to good software design</li>
<li>to be very succinct</li>
<li>to provide trustworthy sources to go deeper</li>
</ul>
<h3><a class="header" href="#who-should-read-this-book" id="who-should-read-this-book">Who should read this book</a></h3>
<p>The book is intended mainly for people who just started their journey into software design or who are in the middle of it.
If you have being seriously studying the topic for 5+ years, likely you are not going to find big surprises. However, I still
suggest you to go through the table of contents: you might find one or two things worth a quick read.
As a last consideration, the book is heavily skewed towards object-oriented programming though many advices apply to all <a href="http://www.cs.albany.edu/%7Esdc/CSI500/Downloads/ProgrammingParadigmsVanRoyChapter.pdf">programming paradigms</a>.
Code examples are written in Kotlin, but they are very basic so you do not need any prior knowledge (Kotlin enthusiasts will forgive me some syntax choices :) ).</p>
<h3><a class="header" href="#who-i-am" id="who-i-am">Who I am</a></h3>
<p>My name is Matteo Di Tucci, I currently work at ThoughtWorks.
I picked up coding in university because I did not know what to do when growing up.
I still do not know, but along the way I pleasantly discovered I like software and its design.</p>
<h3><a class="header" href="#teach-me-back" id="teach-me-back">Teach me back</a></h3>
<p>I really appreciate any feedback about the book and my current understanding of software design.
You can share any feedback by creating a <a href="https://github.com/MatteoDiTucci/software-design/pulls">pull request</a>.
If you do not know what a pull request is, take a look <a href="https://guides.github.com/activities/hello-world/#:%7E:text=Pull%20Requests%20are%20the%20heart,merge%20them%20into%20their%20branch.&amp;text=You%20can%20even%20open%20pull,repository%20and%20merge%20them%20yourself.">here</a>.</p>
<h3><a class="header" href="#simple-code" id="simple-code">Simple code</a></h3>
<p>It is hard to define what good design looks like: nobody was able to come up with a formal definition so far.
An approach I personally like is the <a href="https://wiki.c2.com/?XpSimplicityRules">C2 Wiki</a> simple code rules.<br />
Simple code:</p>
<ul>
<li>Passes all tests</li>
<li>Expresses intent</li>
<li>Does not repeat itself</li>
<li>Does not contain superfluous parts</li>
</ul>
<p>If a piece of code respects all those 4 rules then we can consider it good code.<br />
This book is divided in 4 chapters, one for each of the simple code rules.</p>
<h3><a class="header" href="#reviewers" id="reviewers">Reviewers</a></h3>
<p><a href="https://github.com/agjacome">Alberto G. J√°come</a><br />
<a href="https://github.com/twp88">Thomas Page</a></p>
<h1><a class="header" href="#it-passes-all-tests" id="it-passes-all-tests">It passes all tests</a></h1>
<p>The most important feature for a piece of software is that it behaves as expected. Tests reduce the likelihood of writing
buggy code and without them software development becomes an exercise of faith. Although manually checking that everything works 
still qualifies as testing, the real power resides in automated tests. Writing tests
little by little as we progress with a codebase, creates a safety net that is always available and provides us with an immediate feedback.
It really is a super power and it gives us peace of mind.</p>
<p>Automated tests is one of the three pillars that took anxiety away from my work as a developer. 
The other two are continuous deployment and observability.</p>
<h2><a class="header" href="#test-pyramid" id="test-pyramid">Test pyramid</a></h2>
<p>There are different kinds of tests, each one meant for a different purpose. Before describing the most common ones, let's
clarify in advance a couple of terms. For <em>service</em> we mean a bunch of code deployed as a whole. For
<em>external dependencies</em> we mean anything that is reached over the network, like a database, another team REST endpoint, a queue, third party apis, etc.</p>
<ul>
<li><strong>Acceptance tests</strong><br />
Check that a feature behaves as expected across all service layers (e.g. back end and front end) or even
across different services. External dependencies are replaced through libraries like <a href="https://github.com/localstack/localstack">LocalStack</a>
or <a href="http://wiremock.org/">Wiremock</a>. In a web application for instance, acceptance tests are defined with tools like <a href="https://www.selenium.dev/">Selenium</a>
or <a href="https://www.cypress.io/">Cypress</a>.</li>
<li><strong>Functional tests</strong><br />
Check that a feature behaves as expected considering a single layer of a service. For example, if a service have both back end and
front end, there will be distinct functional tests for the back end and front end. External dependencies are replaced either
by libraries like <a href="https://github.com/localstack/localstack">LocalStack</a> or by <a href="passes-all-tests/test-doubles.html">test doubles</a>.
Functional tests are also called component tests.</li>
<li><strong>Integration tests</strong><br />
Check that a service integrates correctly with external dependencies. External dependencies are replaced by libraries like
<a href="https://github.com/localstack/localstack">LocalStack</a> or <a href="http://wiremock.org/">Wiremock</a>. If <a href="passes-all-tests/test-doubles.html">test doubles</a>
are implemented in code without accessing the network then it is a unit test.</li>
<li><strong>Unit tests</strong><br />
Check that code inside one class behaves as expected. Unit tests are most valuable when testing business logic: if a class is just a
<a href="https://en.wikipedia.org/wiki/Delegation_pattern">delegator</a> or just coordinates other classes, do not use unit tests
as functional tests already provide coverage. If the class under test uses other classes whose construction is cumbersome,
those can be replaced with <a href="passes-all-tests/test_doubles.html">test doubles</a></li>
</ul>
<p>The above list is ordered by how much time a test takes to execute, from the slowest (acceptance) to the fastest (unit).
For this reason, it is recommended to have a pyramid of tests: a handful of acceptance tests, some functional and integration
tests and many unit tests. In particular:</p>
<ul>
<li><strong>Acceptance tests</strong><br />
Only for default uses of a feature</li>
<li><strong>Functional tests</strong><br />
For both default and exceptional-erroneous uses of a feature</li>
<li><strong>Integration tests</strong><br />
For both default and exceptional-erroneous integrations with external dependencies</li>
<li><strong>Unit tests</strong><br />
For both default and exceptional-erroneous usage of a single class</li>
</ul>
<br/>  
<h4><a class="header" href="#recommended-reads" id="recommended-reads">Recommended reads</a></h4>
<ul>
<li><a href="https://martinfowler.com/bliki/TestPyramid.html">Test Pyramid (in short) - Martin Fowler</a></li>
<li><a href="https://martinfowler.com/articles/practical-test-pyramid.html">Test Pyramid (in depth) - Ham Vocke</a></li>
<li><a href="https://www.goodreads.com/book/show/4268826-growing-object-oriented-software-guided-by-tests">Growing Object-Oriented Software, Guided by Tests - Steve Freeman, Nat Pryce</a></li>
<li><a href="https://testing.googleblog.com/2020/11/fixing-test-hourglass.html">Fixing a Test Hourglass, Google testing blog - Alan Myrvold</a></li>
<li><a href="https://martinfowler.com/articles/2021-test-shapes.html">Test Pyramid vs Test Trophy - Martin Fowler</a></li>
<li><a href="https://martinfowler.com/articles/practical-test-pyramid.html">The Practical Test Pyramid - Ham Vocke</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-1" id="teach-me-back-1">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#if-testing-is-hard-inject-what-you-need-to-verify" id="if-testing-is-hard-inject-what-you-need-to-verify">If testing is hard, inject what you need to verify</a></h2>
<p>When you have a hard time testing something, the solution is usually to inject the thing you would like to verify.
Suppose we are starting to implement a <code>Car</code> class that stores passengers by their name.</p>
<pre><code class="language-kotlin">class Car {
  private val passengers: MutableSet&lt;String&gt; = HashSet()
    
  fun storePassenger(name: String) {
    passengers.add(name)
  }
}
</code></pre>
<p>How to test that the method <code>storePassenger(name: String)</code> stores a name into the <code>passengers</code> set?
The typical solution is to define another method in <code>Car</code> to check if it contains a passenger.</p>
<pre><code class="language-kotlin">class Car {
  private val passengers: MutableSet&lt;String&gt; = HashSet()
    
  fun storePassenger(name: String) {
    passengers.add(name)
  }
       
  fun containsPassenger(name: String): Boolean { 
    return passengers.contains(name)
  }
}
</code></pre>
<p>So we can write the following test</p>
<pre><code class="language-kotlin">@Test
fun `stores the names of the passengers`() {
  val car = Car()
  
  car.storePassenger(&quot;Andrea&quot;)

  assertTrue(passengers.containsPassenger(&quot;Andrea&quot;))
}
</code></pre>
<p>However, this is already a disappointment because we are forced to write a public method just for the sake of testing.
Moreover, what if by specifications we must prevent any other code to query <code>Car</code> about its passengers?
The solution can be to inject the <code>passengers</code> set a construction time.</p>
<pre><code class="language-kotlin">class Car(private val passengers: MutableSet&lt;String&gt;) {

  fun storePassenger(name: String) {
    passengers.add(name)
  }
}
</code></pre>
<p>Now we can test like follows.</p>
<pre><code class="language-kotlin">@Test
fun `stores the names of the passengers`() {
  val passengers = HashSet()
  val car = Car(passengers)
  
  car.storePassenger(&quot;Andrea&quot;)

  assertTrue(passengers.contains(&quot;Andrea&quot;))
}
</code></pre>
<p>By injecting the <code>passengers</code> set we can get rid of the useless <code>containsPassenger</code> method. Furthermore, we have now the
opportunity to make our code more modular, making <code>Car</code> independent of the data structure used to store the passengers.
For this, we can use <code>MutableCollection&lt;String&gt;</code> instead of <code>MutableSet&lt;String&gt;</code></p>
<pre><code class="language-kotlin">class Car(private val passengers: MutableCollection&lt;String&gt;) {

  fun storePassenger(name: String) {
    passengers.add(name)
  }
}
</code></pre>
<br/>  
<h4><a class="header" href="#recommended-reads-1" id="recommended-reads-1">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/4268826-growing-object-oriented-software-guided-by-tests">Context independence section, chapter 6 of Growing Object-Oriented Software, Guided by Tests - Steve Freeman, Nat Pryce</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-2" id="teach-me-back-2">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#test-doubles" id="test-doubles">Test doubles</a></h2>
<p>When testing a class, often we need to create a lot of objects just for the sake of the test. This happens for two reasons:</p>
<ul>
<li>All those objects are needed to make the test run (e.g. they are required by the constructor of the class under test)</li>
<li>We want to verify how the class under test interacts with those objects (e.g. if the class under test calls the public method of another one)</li>
</ul>
<p>Because of the above, tests can become time-consuming and tedious. Fortunately, we can remediate by using test doubles. For the sake
of development speed, test doubles are usually created via testing libraries. For instance, in Kotlin there is
<a href="https://mockk.io/">MockK</a> among others. Taking the following code as example, let's define the different types of test doubles
and how they look like in a test when using a library like MockK.</p>
<pre><code class="language-kotlin">class Greeter(private val validator: Validator) {

  fun greetings(): String {
    return &quot;Hello&quot;
  }

  fun personalisedGreetings(name: String): String {
    if (validator.isValid(name))
      return &quot;Hello $name&quot;
    
    return &quot;Not a valid name&quot;
  }
}

class Validator {

  fun isValid(name: String): Boolean {
    if (name.isEmpty())
      return false
    
    return true
  }
}
</code></pre>
<p><strong>Stubs</strong><br />
They return a hardcoded response. In the following test, <code>validator</code> is a stub. Unfortunately mocks
and stubs in MockK are both defined as <code>mockk&lt;&gt;()</code> which makes it confusing for newcomers.</p>
<pre><code class="language-kotlin">@Test
  fun `greets by name`() {
    val validator = mockk&lt;Validator&gt;()
    every{ validator.isValid(&quot;Andrea&quot;) } returns true
    val controller = Greeter(validator)
  
    val result = controller.personalisedGreetings(&quot;Andrea&quot;)
  
    assertEquals(&quot;Hello Andrea&quot;, result)
  }
</code></pre>
<p><strong>Mocks</strong><br />
They have two responsibilities:</p>
<ul>
<li>they return a hardcoded response</li>
<li>the test checks that their public methods are called with specific input parameters</li>
</ul>
<p>In the following test,
<code>validator</code> is a mock.</p>
<pre><code class="language-kotlin">@Test
  fun `performs successful validation on the name`() {
    val validator = mockk&lt;Validator&gt;()
    every{ validator.isValid(&quot;Andrea&quot;) } returns true
    val controller = Greeter(validator)
  
    controller.personalisedGreetings(&quot;Andrea&quot;)
  
    verify{ validator.isValid(&quot;Andrea&quot;) }
  }
</code></pre>
<p><strong>Spies</strong><br />
The test checks that their public methods are called with specific input parameters. In the
following test, <code>validator</code> is spy.</p>
<pre><code class="language-kotlin">@Test
  fun `performs validation on the name`() {
    val name = &quot;Andrea&quot;
    val validator = spyk&lt;Validator&gt;()
    val controller = Greeter(validator)

    controller.personalisedGreetings(name)

    verify{ validator.isValid(name) }
  }
</code></pre>
<p><strong>Dummies</strong><br />
They are used to run the test but they do not take any part in it, meaning no public method of theirs is called.
For instance, <code>validator</code> in the following test is a dummy as the method <code>greetings</code> does not interact with <code>validator</code>.</p>
<pre><code class="language-kotlin">@Test
  fun `greets by saying Hello`() {
    val validator = mockk&lt;Validator&gt;()
    val controller = Greeter(validator)

    val result = controller.greetings()

    assertEquals(&quot;Hello&quot;, result)
  }
</code></pre>
<p><strong>Fakes</strong><br />
An object with very limited capabilities compared to the real one but much faster to create. The typical example is
an in memory database (e.g. H2) instead of a production one (e.g. PostgreSQL)</p>
<p>As a final note, test doubles are not used just for unit tests, but throughout the <a href="passes-all-tests/test-pyramid.html">whole testing pyramid</a>.</p>
<br/>
<h4><a class="header" href="#recommended-reads-2" id="recommended-reads-2">Recommended reads</a></h4>
<ul>
<li><a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks aren't stubs - Martin Fowler</a></li>
<li><a href="https://www.goodreads.com/book/show/4268826-growing-object-oriented-software-guided-by-tests">Only mock type that you own, chapter 8 of Growing Object-Oriented Software, Guided by Tests - Steve Freeman, Nat Pryce</a></li>
<li><a href="https://github.com/testdouble/contributing-tests/wiki/Don%27t-mock-what-you-don%27t-own">Don't mock what you don't own, contributing-tests wiki - Justin Searls</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-3" id="teach-me-back-3">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#test-driven-development" id="test-driven-development">Test driven development</a></h2>
<p>Test driven development (TDD) is an approach to development where tests are written before the actual code. The core of TDD is a three
steps process:</p>
<ol>
<li>Write a failing test</li>
<li>Make the test pass</li>
<li>Refactor</li>
</ol>
<p>Let's go through each step using the following specifications as example:</p>
<ul>
<li>I want measure things in meters</li>
<li>I want to be able to sum two measurements in meters</li>
</ul>
<p><strong>Write a failing test</strong><br />
At this step we pick a single aspect of the specification we want to verify: the smallest the better. The common mistake
here is to overthink it because we want to take into account all the specifications and their nuances. Don't do it now,
the third step will take care of it. For now let's just write a test even if it seems silly for how simple it is. Moreover,
don't focus on writing good code either: the third step will take care of this as well. Finally, remember to run the test
and see it failing with the error we expect: we do not want to later discover that our tests are passing by luck.</p>
<pre><code class="language-kotlin">@Test
fun `summing 1 meter and 2 meters returns 3 meters`() {
  val result = MeasureInMeters(1).add(MeasureInMeters(2))

  assertEquals(MeasureInMeters(3), result)
}
</code></pre>
<p><strong>Make the test pass</strong><br />
Now that we have a failing test we need to make it pass. Be mindful that compilation errors in the test is the same of
running it and see it fail. At this step as at the previous, let's not focus about writing good code, that's something for
the third step: just make the test pass, whatever it takes.</p>
<pre><code class="language-kotlin">data class MeasureInMeters(private val amount: Int) {

  fun add(measureInMeters: MeasureInMeters): MeasureInMeters {
    return MeasureInMeters(3)
  }
}
</code></pre>
<p>(In Kotlin, the <code>data class</code> keyword makes sure that two instances of <code>Meter</code> are equal if their <code>amount</code> is equal).</p>
<p><strong>Refactor</strong><br />
In this step we improve the test and the actual code we have written. Let's start from the naming.</p>
<pre><code class="language-kotlin">@Test
fun `adding 1 meter and 2 meters returns 3 meters`() {
  val result = Measure(1).add(Measure(2))

  assertEquals(Measure(3), result)
}

data class Measure(private val amount: Int) {

  fun add(measure: Measure): Measure {
    return Measure(3)
  }
}
</code></pre>
<p>Let's also generalise the body of the method <code>sum</code> for all integers as we already understand it won't work for another
pair of numbers.</p>
<pre><code class="language-kotlin">data class Measure(private val amount: Int) {

  fun add(measure: Measure): Measure {
    return Measure(amount + measure.amount)
  }
}
</code></pre>
<p>The third step is also when we look at the bigger picture. In this example there is little to do, but usually this is the moment
when we pay attention on how the new code we are writing fits into the existing codebase (e.g. knowledge
duplication, edge cases for some other classes we did not think before, etc.). We do not need to address these concerns
right away, but it is good to note them down so we can tackle them once we have done satisfying the bit of specifications
we are currently working on. Once we are happy with the quality of the code we have just written, we can restart
the three steps process. The focus will be either another test for the bit of specification we are focusing on
(e.g. adding 2 negative integers) or a test for another bit of the specifications.</p>
<p>Compared to writing tests after the implementation, the main benefit of TDD is that it becomes much harder to write code
that is not tested. However, be mindful that we can still write buggy code even if we use TDD as described in the
<a href="passes-all-tests/test-coverage-is-not-enough.html">test coverage is not enough</a> section.</p>
<br/>  
<h4><a class="header" href="#recommended-reads-3" id="recommended-reads-3">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/387190.Test_Driven_Development">Test-Driven Development: By Example - Kent Beck</a></li>
<li><a href="https://www.goodreads.com/book/show/4268826-growing-object-oriented-software-guided-by-tests">Growing Object-Oriented Software, Guided by Tests - Steve Freeman, Nat Pryce</a></li>
<li><a href="https://www.goodreads.com/book/show/31183020-99-bottles-of-oop">Shameless green, chapter 1 of 99 bottles of OOP, Sandy Metz</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2017/10/03/TestContravariance.html">Test contravariance - Robert C. Martin</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2016/06/10/MutationTesting.html">&quot;Testing shows the presence, not the absence of bugs&quot; - Edsger W. Dijkstra</a></li>
<li><a href="https://github.com/testdouble/contributing-tests/wiki/London-school-TDD">London vs Chicago school, contributing-tests wiki - Justin Searls</a></li>
<li><a href="http://jmock.org/oopsla2004.pdf">Need driven development, Mock Roles, not Objects - Steve Freeman, Nat Pryce, Tim Mackinnon, Joe Walnes</a></li>
<li><a href="https://cleancoders.com/series/comparativeDesign">London vs Chicago - Robert C. Martin, Sandro Mancuso</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-4" id="teach-me-back-4">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#test-coverage-is-not-enough" id="test-coverage-is-not-enough">Test coverage is not enough</a></h2>
<p>Test coverage measures how much code in a codebase is invoked when we run all tests. However, it is not a measure of quality
of the tests. This means a codebase with 100% of coverage can still be plenty of bugs. Let's take as example the following code.</p>
<pre><code class="language-kotlin">data class Bill(private val amount: Int) {

  fun split(parts: Int): Bill {
    return Bill(amount / parts)
  }
}

@Test
fun `split the bill in equal parts for 4 people`() {
  val bill = Bill(100)

  val result = bill.split(4)

  assertEquals(Bill(25), result)
}
</code></pre>
<p>(In Kotlin, the <code>data class</code> keyword makes sure that two instances of <code>Bill</code> are equal if their <code>amount</code> is equal).</p>
<p>The above code has 100% test coverage. However, we could break it by simply calling <code>split(0)</code> over <code>Bill</code>.
For this reason, it is important to test against as many inputs as possible. For instance, in the above example this means
trying different input parameters for the <code>Bill</code> constructor and for the <code>split</code> method. Defining one test for each possible
combination of inputs is not feasible, but there are some testing methodologies that let us test for many inputs in very little time:</p>
<ul>
<li>Parameterized testing: execute one test multiple times specifying different input parameters</li>
<li>Property based testing: execute one test multiple times specifying which kind of inputs are valid and letting a library randomly generate them</li>
</ul>
<br/>  
<h4><a class="header" href="#recommended-reads-4" id="recommended-reads-4">Recommended reads</a></h4>
<ul>
<li><a href="https://www.baeldung.com/parameterized-tests-junit-5">Parameterised testing with Junit in Kotlin - Baeldung</a></li>
<li><a href="https://jqwik.net/">Jqwik, a property based testing library in Java</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fuzzing">Fuzz testing</a></li>
<li><a href="https://en.wikipedia.org/wiki/Formal_verification">Formal verification</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-5" id="teach-me-back-5">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#test-must-be-reproducible" id="test-must-be-reproducible">Test must be reproducible</a></h2>
<p>A test must not change throughout different executions, otherwise we would be running a different test every time.
The risk is ending up with tests that fail without apparent reason or worse with tests passing despite the presence of bugs. 
Let's consider the following example.</p>
<pre><code class="language-kotlin">class AnnualSubscription(private val validityYear: Int) {

  fun isValid(currentDate: LocalDate): Boolean {
    return validityYear == currentDate.year
  }
}

@Test
fun `is valid during the year the subscription was made`() {
    val book = AnnualSubscription(2021)

    val result = book.isValid(LocalDate.now()) // today is the 3rd of March 2021

    assertTrue(result)
}
</code></pre>
<p>The above test always passes during 2021. However, it will start failing from the 1st of January 2022 because of <code>LocalDate.now()</code>.
To make the test deterministic we have to replace <code>LocalDate.now()</code> with a constant date like follows.</p>
<pre><code class="language-kotlin">@Test
  fun `is valid during the year the subscription was made`() {
    val book = AnnualSubscription(2021)

    val result = book.isValid(LocalDate.of(2021, Month.MARCH, 3))

    assertTrue(result)
  }
</code></pre>
<br/>
<h4><a class="header" href="#recommended-reads-5" id="recommended-reads-5">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/13541678-functional-programming-in-scala">Purely functional random number generation, chapter 6 of Functional Programming in Scala - R√∫nar Bjarnason, Paul Chiusano, Tony Morris</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-6" id="teach-me-back-6">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#no-production-code-constants-in-tests" id="no-production-code-constants-in-tests">No production code constants in tests</a></h2>
<p>When writing tests, we might be tempted to use production code constants to remove duplication. This creates a 
conflict of interests by which a test is defined using part of the code that is supposed to test. Such a situation 
can lead to bugs going unnoticed like in the following example.</p>
<p>(In Kotlin, <code>companion object</code> is the way to define constants known at compile time, the equivalent of <code>static</code> in Java)</p>
<pre><code class="language-kotlin">class Greeter {

  fun greet(name: String): String {
    return &quot;$DEFAULT_GREETING $name&quot;
  }

  companion object {
    const val DEFAULT_GREETING: String = &quot;Hello&quot;
  }
}

@Test
fun `greet by name`() {
  val greeter = Greeter()

  val result = greeter.greet(&quot;Andrea&quot;)

  assertEquals(&quot;${Greeter.DEFAULT_GREETING} Andrea&quot;, result)
}
</code></pre>
<p>The problem with the above code is that if by mistake we change the value of <code>DEFAULT_GREETING</code> from <code>&quot;Hello&quot;</code> to <code>&quot;Hellozxhgj&quot;</code>
the test will still pass as it would be expecting <code>&quot;Hellozxhgj Andrea&quot;</code>. To catch this kind of bugs is 
enough not to use the production constant <code>DEFAULT_GREETING</code> in the test like follows.</p>
<pre><code class="language-kotlin">@Test
  fun `greet by name`() {
    val greeter = Greeter()

    val result = greeter.greet(&quot;Andrea&quot;)

    assertEquals(&quot;Hello Andrea&quot;, result)
  }
</code></pre>
<h4><a class="header" href="#teach-me-back-7" id="teach-me-back-7">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#do-not-test-libraries" id="do-not-test-libraries">Do not test libraries</a></h2>
<p>Here also mention to not mock what you don't own and to use an adapter pattern instead</p>
<br/>  
<h4><a class="header" href="#recommended-reads-6" id="recommended-reads-6">Recommended reads</a></h4>
<ul>
<li><a href="https://github.com/mockito/mockito/wiki/How-to-write-good-tests#dont-mock-a-type-you-dont-own">Don't mock a type you don't own! - Mockito wiki</a></li>
<li><a href="https://8thlight.com/blog/eric-smith/2011/10/27/thats-not-yours.html">That's Not Yours - Eric Smith</a></li>
<li><a href="https://davesquared.net/2011/04/dont-mock-types-you-dont-own.html">Don't mock types you don't own - David Tchepak</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-8" id="teach-me-back-8">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#expand-and-contract" id="expand-and-contract">Expand and contract</a></h2>
<p>When we change the signature of a public method, we need to adjust all its client code accordingly. 
In big codebases this implies a single, time-consuming refactoring which can lead to version control conflicts (e.g. git merge conflicts)
with other developers. However, we can break down this big refactoring into smaller steps by leveraging a technique called expand and contract.
Let's take the following code as an example:</p>
<pre><code class="language-kotlin">import java.math.BigDecimal

class Price(private val amount: BigDecimal) {

    fun discountedOf(percentage: BigDecimal): Price { 
        val discount = amount.multiply(percentage.divide(BigDecimal(100)))
        return Price(amount.subtract(discount))
    }
}
</code></pre>
<p>The <code>percentage</code> input parameter of the method <code>discountedOf</code> can be problematic as there is no guarantee for it to be between 0 and 100.
For this reason, we want to introduce a class <code>Percentage</code> so that the signature of the method <code>discountedOf</code> can become <code>discountedOf(percentage: Percentage)</code>.
Let's see how we can do this in small steps with the expand and contract technique.</p>
<h3><a class="header" href="#1-expand" id="1-expand">1. Expand</a></h3>
<p>Instead of modifying the signature of the method <code>discountedOf</code> right away, we add a new method <code>newDiscountedOf</code> which has the desired new signature:</p>
<pre><code class="language-kotlin">import java.math.BigDecimal

class Price(private val amount: BigDecimal) {

    fun newDiscountedOf(percentage: Percentage): Price {
        val discount = percentage.of(amount)
        return Price(amount.subtract(discount))
    }

    fun discountedOf(percentage: BigDecimal): Price {
        val discount = amount.multiply(percentage.divide(BigDecimal(100)))
        return Price(amount.subtract(discount))
    }
}

class Percentage(private val percentage: BigDecimal) {
    init {
        require(percentage in BigDecimal(0)..BigDecimal(100) ) {
            &quot;Percentage must be between 0 and 100&quot;
        }
    }

    fun of(amount: BigDecimal): BigDecimal {
        return amount.multiply(percentage.divide(BigDecimal(100)))
    }
}
</code></pre>
<p>At this point for the client code nothing has changed: everybody still use the method <code>discountedOf</code> while <code>newDiscountedOf</code>
is dead code.</p>
<h3><a class="header" href="#2-migrate-clients-one-by-one" id="2-migrate-clients-one-by-one">2. Migrate clients one by one</a></h3>
<p>Now we can migrate the client code. However, instead of doing it all at once, we can refactor one client at a time.
In this way we can gradually increase the usage of <code>newDiscountedOf</code> while reducing the one of <code>discountedOf</code>.
Each client migration can be a standalone code revision (git commit), so the changes are small and incremental while 
the entire codebase keeps working as expected.</p>
<h3><a class="header" href="#3-contract" id="3-contract">3. Contract</a></h3>
<p>When all clients have been migrated, the method <code>discountedOf</code> is now dead code, so we can delete it and rename the method
<code>newDiscountedOf</code> into <code>discountedOf</code>. The final result looks like the following:</p>
<pre><code class="language-kotlin">import java.math.BigDecimal

class Price(private val amount: BigDecimal) {

    fun discountedOf(percentage: Percentage): Price {
        val discount = percentage.of(amount)
        return Price(amount.subtract(discount))
    }
}

class Percentage(private val percentage: BigDecimal) {
    init {
        require(percentage in BigDecimal(0)..BigDecimal(100) ) {
            &quot;Percentage must be between 0 and 100&quot;
        }
    }

    fun of(amount: BigDecimal): BigDecimal {
        return amount.multiply(percentage.divide(BigDecimal(100)))
    }
}
</code></pre>
<p>The end result is the same as we would have done it in one shot. However, we made the refactoring more maneageable by
breaking it down into smaller steps.</p>
<h3><a class="header" href="#further-applications" id="further-applications">Further applications</a></h3>
<p>Expand and contract is very useful to avoid merge conflicts, no matter if you are using <a href="https://martinfowler.com/articles/branching-patterns.html">trunk base development or feature branches</a>.
Especially with trunk based development, it plays very well with the use of <a href="https://martinfowler.com/articles/feature-toggles.html">feature toggles</a>.</p>
<p>Furthermore, despite the above example is about a class method, the same approach is applicable to api contracts.
Let's assume for instance a POST REST API with the following body:</p>
<pre><code class="language-json">{
  &quot;price&quot; : 72.9,
  &quot;discount&quot; : 15
}
</code></pre>
<p>Then, let's assume we want to change <code>&quot;discount&quot;</code> from an integer to a percentage expressed as a decimal between 0 and 1.
Using the expand and contract approach, we would first expand:</p>
<pre><code class="language-json">{
  &quot;price&quot; : 72.9,
  &quot;discount&quot; : 15,
  &quot;discount_percentage&quot; : 0.15
}
</code></pre>
<p>Then migrate all clients to use <code>&quot;discount_percentage&quot;</code> instead of <code>&quot;discount&quot;</code> and finally contract:</p>
<pre><code class="language-json">{
  &quot;price&quot; : 72.9,
  &quot;discount_percentage&quot; : 0.15
}
</code></pre>
<p>Last but not least, we can use expand and contract also for database schema migrations.</p>
<br/>  
<h4><a class="header" href="#recommended-reads-7" id="recommended-reads-7">Recommended reads</a></h4>
<ul>
<li><a href="https://oooops.dev/2021/07/30/surviving-continuous-deployment-in-distributed-systems/">Surviving continuous deployment in distributed systems - Valentina Servile</a></li>
<li><a href="https://www.goodreads.com/book/show/161302.Refactoring_Databases">Refactoring Databases: Evolutionary Database Design - Scott Ambler, Pramod Sadalage</a></li>
<li><a href="https://www.infoq.com/presentations/The-Limited-Red-Society/">Parallel change - Scott Ambler, Joshua Kerievsky</a></li>
<li><a href="https://martinfowler.com/bliki/ParallelChange.html">Parallel change - Danilo Sato</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-9" id="teach-me-back-9">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#performance-tests" id="performance-tests">Performance tests</a></h2>
<br/>  
<h4><a class="header" href="#recommended-reads-8" id="recommended-reads-8">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/1069827.Release_It_">Release It!: Design and Deploy Production-Ready Software (2nd edition) - Michael T. Nygard</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-10" id="teach-me-back-10">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#how-to-test-ui" id="how-to-test-ui">How to test UI</a></h2>
<p>screenshot and snapshot testing</p>
<h1><a class="header" href="#linting" id="linting">Linting</a></h1>
<h2><a class="header" href="#test-for-production" id="test-for-production">Test for production</a></h2>
<p>Correct code which passes all tests can still fail once deployed in production.
This happens because tests do not account for failures.<br />
Example of failures are external apis being slow to respond or a spike of user requests saturating hardware resources.
To make our code resilient we need to embrace failure and mitigate its impact.</p>
<p>Failure usually happen where our code accesses the network (e.g. database, external api, etc.).
The following approaches help to mitigate its impact:</p>
<ul>
<li><strong>Fail fast</strong><br />
When an external dependency is down, it is better to present users with errors for some functionality than bringing down the whole application.
Use timeouts and circuit breakers on client side.</li>
<li><strong>Isolate failures</strong><br />
Each integration point should have its own pool of resources (e.g. thread pool, connection pool, etc.)
Use bulkheads.</li>
<li><strong>Buffer loads</strong><br />
Improve availability by absorbing load in buffers.
Use queues and user notifications instead of synchronous responses.</li>
<li><strong>Test error scenarios</strong><br />
Use integration tests that simulates error cases like server timeout, connection error, slow responses, etc.</li>
</ul>
<br/>  
<h4><a class="header" href="#recommended-reads-9" id="recommended-reads-9">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/1069827.Release_It_">Release It!: Design and Deploy Production-Ready Software (2nd edition) - Michael T. Nygard</a></li>
<li><a href="https://en.wikipedia.org/wiki/Chaos_engineering">Chaos Engineering - Wikipedia</a></li>
<li><a href="https://developers.redhat.com/blog/2017/05/16/it-takes-more-than-a-circuit-breaker-to-create-a-resilient-application">It takes more than a Circuit Breaker to create a resilient application - Bilgin Ibryam</a></li>
<li><a href="https://netflixtechblog.com/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a">Fault Tolerance in a High Volume, Distributed System - Ben Christensen</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker">Circuit breaker pattern - Microsoft</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead">Bulkhead pattern - Microsoft</a></li>
<li><a href="https://about.gitlab.com/topics/devsecops/what-is-fuzz-testing/">Fuzz testing - Gitlab</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-11" id="teach-me-back-11">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#tests-for-distributed-systems" id="tests-for-distributed-systems">Tests for distributed systems</a></h2>
<p>When testing a functionality that spans across multiple microservices, there are some tradeoffs to make between tests maintainability and coverage.
As an example, let's take a Price microservice which needs to contact three other microservices to be able to calculate a price.
We are responsible for the Price microservice only, while other teams take care of Membership, Discount and Inventory microservices respectively.<br />
<img src="passes-all-tests/images/distributed-systems-example.png" alt="distributed-systems-example.png" /></p>
<p>Let's assume we want to write an acceptance test to verify the functionality of calculating a price.
For this purpose, we need also the other three microservices to be up running while the acceptance test runs.
Usually there are four ways to achieve this. Each one has pros and cons, but in my experience, the first has proved to be superior.<br />
In all four alternatives, when we say locally, we mean both the developers laptops and the <a href="https://martinfowler.com/articles/continuousIntegration.html">continuous integration</a> machine.</p>
<h3><a class="header" href="#stub-the-three-microservices-integration-locally-and-use-in-depth-smoke-tests" id="stub-the-three-microservices-integration-locally-and-use-in-depth-smoke-tests">Stub the three microservices integration locally and use in depth smoke tests</a></h3>
<p>The acceptance test is converted into a functional test that runs locally and a smoke test that runs against the different environments (e.g. development and production).
Regarding the functional test, the Price service is started by stubbing the integration with the other three microservices.
This means that despite the integration with the three microservices might happen over https, when the functional test runs, there is no network or other infrastructure involved.</p>
<p>Regarding the smoke test, it triggers the real integration between the four microservices, as a production shopper request would do.</p>
<p>Pros:</p>
<ul>
<li>The smoke test verifies the real logic for both 4 microservices</li>
<li>No extra infrastructure needed locally</li>
<li>No powerful hardware needed locally</li>
<li>Chance of writing many functional tests in exchange for the acceptance test as the former is faster to run, write and maintain than the latter</li>
<li>No need to worry about authentication at functional test level</li>
</ul>
<p>Cons:</p>
<ul>
<li>Integration bugs between microservices cannot be caught locally: they will be visible during the smoke test execution.<br />
This late feedback loop around integration can be fixed by using contract testing (see resources section below)</li>
<li>Difficult to stub the three microservices integration if infrastructure is mixed with domain inside the Price service codebase</li>
</ul>
<h3><a class="header" href="#integrate-with-the-other-three-microservices-deployed-in-dev-environment" id="integrate-with-the-other-three-microservices-deployed-in-dev-environment">Integrate with the other three microservices deployed in dev environment</a></h3>
<p>This implies that the acceptance test reaches out to the dev environment where Inventory, Discount and Membership microservices are deployed.</p>
<p>Pros:</p>
<ul>
<li>The acceptance test verifies the real logic for both 4 microservices, nothing is stubbed</li>
<li>No extra infrastructure needed locally</li>
<li>No powerful hardware needed</li>
</ul>
<p>Cons</p>
<ul>
<li>Network connectivity is needed</li>
<li>Extra network configuration (e.g. VPN, firewall rules)</li>
<li>Risk of race conditions on test data related to the three microservices as multiple devs and continuous integration machine might run tests simultaneously</li>
<li>Extra work possibly needed for authentication</li>
</ul>
<h3><a class="header" href="#run-the-other-three-microservices-locally" id="run-the-other-three-microservices-locally">Run the other three microservices locally</a></h3>
<p>This implies fetching the executables of the other three microservices (e.g. Docker images, jar, etc.) and running them locally while the acceptance test is executed.</p>
<p>Pros:</p>
<ul>
<li>The acceptance test verifies the real logic for both 4 microservices, nothing is stubbed</li>
</ul>
<p>Cons:</p>
<ul>
<li>Acceptance test is slow as all fours microservices have to startup first</li>
<li>More powerful hardware is needed (usually ram and cpu) locally</li>
<li>Extra infrastructure is needed to make available the Inventory, Discount and Membership microservices executables (e.g. VPN, access policies configuration, firewall rules, etc.)</li>
<li>Extra setup is needed locally to run the acceptance tests (e.g. install Docker)</li>
<li>Extra work possibly needed for user authentication</li>
</ul>
<h3><a class="header" href="#stub-the-three-microservices-locally" id="stub-the-three-microservices-locally">Stub the three microservices locally</a></h3>
<p>This implies using libraries like <a href="https://wiremock.org/docs/getting-started/">WireMock server</a> to stub the responses from the other three microservices.</p>
<p>Pros:</p>
<ul>
<li>No network connectivity needed</li>
</ul>
<p>Cons:</p>
<ul>
<li>Slower acceptance test as 3 microservices stubs need to startup</li>
<li>External library as extra test dependency</li>
<li>If any api contract change happens in the other three microservices, the acceptance test won't fail</li>
<li>Requires effective and timely communication between the four microservices teams to notify and adjust any api contract change</li>
</ul>
<br/>  
<h4><a class="header" href="#recommended-reads-10" id="recommended-reads-10">Recommended reads</a></h4>
<ul>
<li><a href="https://martinfowler.com/articles/microservice-testing/">Testing strategies in a microservice architecture - Toby Clemson</a></li>
<li><a href="https://martinfowler.com/articles/practical-test-pyramid.html#ContractTests">Contract testing - Ham Vocke</a></li>
<li><a href="https://martinfowler.com/articles/qa-in-production.html">QA in production - Rouan Wilsenach</a></li>
<li><a href="https://martinfowler.com/bliki/SyntheticMonitoring.html">Synthetic Monitoring - Fl√°via Fal√©, Serge Gebhardt</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-12" id="teach-me-back-12">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#test-infrastructure" id="test-infrastructure">Test infrastructure</a></h2>
<br/>  
<h4><a class="header" href="#recommended-reads-11" id="recommended-reads-11">Recommended reads</a></h4>
<ul>
<li><a href="https://medium.com/worldwide-writing-network/test-driven-development-with-terraform-8cb6b86017c">Test-driven development with Terraform - Amit Kumar Dube</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-13" id="teach-me-back-13">Teach me back</a></h4>
<p>I really appreciate any <a href="passes-all-tests/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h1><a class="header" href="#it-expresses-intent" id="it-expresses-intent">It expresses intent</a></h1>
<p>Before changing a piece of code, we first need to understand its intention, meaning what it is supposed to do. 
Not understanding code, or even worse misunderstanding it, leads to a great waste of time. Therefore,
pouring effort in clarifying code intent is a sound investment as code is written once and read many times. </p>
<p>Software design is a collaborative activity and code intent is the expression of people mental representations.
This means that clear code intent starts with effective communication: knowledge sharing, visualising mental models,
using a shared vocabulary.</p>
<h2><a class="header" href="#naming" id="naming">Naming</a></h2>
<p>Great naming let us understand what the code means without inspecting its details. In fact, we should be able
to understand an entire codebase just reading the names of classes, methods and variables, never looking at what they contain.
This clarity is reached by naming classes, methods and variables after what they do instead of how they do it.
The how can be looked up later if more details are needed by inspecting the content. The benefits are two:</p>
<ul>
<li>names do not contain any noise</li>
<li>if the implementation changes, the name remains relevant</li>
</ul>
<p>Let's consider the following class</p>
<pre><code class="language-kotlin">class BiDimensionalCoordinates(private val x: Int, private val y: Int) {
  
  fun sumByXandY(addend: BiDimensionalCoordinates): BiDimensionalCoordinates {
    return BiDimensionalCoordinates(x + addend.x, y + addend.y)
  }
}
</code></pre>
<p>In the above code, both class and method names leak the how. Given the distinction we made about the what and the how,
we can ask ourselves two questions. The first one is: if we remove the how from the <code>BiDimensionalCoordinates</code> names, does the class
still express intent? Let's see.</p>
<pre><code class="language-kotlin">class Coordinates(private val x: Int, private val y: Int) {
  
  fun sum(addend: Coordinates): Coordinates {
    return Coordinates(x + addend.x, y + addend.y)
  }
}
</code></pre>
<p>The answer is yes, as the above class still expresses clear intent, without even bothering the reader with the noise of the how.
The second questions is: would the naming in <code>BiDimensionalCoordinates</code> still make sense if we were to switch to three-dimensional
coordinates? Let's see.</p>
<pre><code class="language-kotlin">class BiDimensionalCoordinates(private val x: Int, 
                               private val y: Int, 
                               private val z: Int) {
  
  fun sumByXandY(addend: BiDimensionalCoordinates): BiDimensionalCoordinates {
    return BiDimensionalCoordinates(x + addend.x, y + addend.y, z + addend.z)
  }
}
</code></pre>
<p>The answer is no. <code>BiDimensionalCoordinates</code> now does not express its intent anymore as it is lying to the reader:
the names suggest two dimensions coordinates when they are actually three. However, the <code>Coordinates</code> class would still express
its intent even when using three dimensions as shown below.</p>
<pre><code class="language-kotlin">class Coordinates(private val x: Int,
                  private val y: Int,
                  private val z: Int) {
  
  fun sum(addend: Coordinates): Coordinates {
    return Coordinates(x + addend.x, y + addend.y, z + addend.z)
  }
}
</code></pre>
<p>As a final note for typed languages, be mindful that the return type of a method is part of its naming. A method <code>sum</code>
does not clearly expresses intent if its signature is like the following: <code>fun sum(addend: Coordinates): Int</code></p>
<br/>  
<h4><a class="header" href="#recommended-reads-12" id="recommended-reads-12">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/31183020-99-bottles-of-oop">Names, section 1.1.1 of 99 bottles of OOP - Sandy Metz</a></li>
<li><a href="https://www.goodreads.com/book/show/31183020-99-bottles-of-oop">Choosing Names, section 2.8 of 99 bottles of OOP - Sandy Metz</a></li>
<li><a href="https://www.goodreads.com/book/show/3735293-clean-code">Meaningful Names, chapter 2 of Clean Code - Robert C. Martin</a></li>
<li><a href="https://www.goodreads.com/en/book/show/44936.Refactoring">Replace Magic Number with Symbolic Constant, chapter 8 of Refactoring - Martin Fowler</a></li>
<li><a href="https://www.barnesandnoble.com/w/domain-driven-design-distilled-vaughn-vernon/1124175630">Developing a Ubiquitous Language, chapter 2 of Domain-Driven Design Distilled - Vaughn Vernon</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-14" id="teach-me-back-14">Teach me back</a></h4>
<p>I really appreciate any <a href="expresses-intent/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#deep-and-narrow-classes" id="deep-and-narrow-classes">Deep and narrow classes</a></h2>
<p>We are doomed to write convoluted code when interacting with classes that have poor public methods. On the contrary,
we are brought to write readable code when interacting with classes that have great public methods. Let's consider 
the following <code>play</code> public method for the <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz game</a>.</p>
<pre><code class="language-kotlin">class FizzBuzz {

  fun play(number: Int): String {
  
    if (number % 5 == 0 &amp;&amp; number % 3 == 0)
      return &quot;fizz buzz&quot;
  
    if (number % 5 == 0)
      return &quot;buzz&quot;

    if (number % 3 == 0)
      return &quot;fizz&quot;

    return number.toString()
  }
}
</code></pre>
<p>The above signature of the <code>play</code> method leads to the following code when playing with the numbers between 1 and 100.</p>
<pre><code class="language-kotlin">class App {

  fun main() {
 
    val fizzBuzz = FizzBuzz()    
    val result = ArrayList&lt;String&gt;()
    
    for (number in 1..100)
      result.add(fizzBuzz.play(number))
  }
}
</code></pre>
<p>Now, let's change the signature of the <code>play</code> method like follows.</p>
<pre><code class="language-kotlin">class FizzBuzz {

  fun play(from: Int, to: Int): List&lt;String&gt; {
  
    val result = ArrayList&lt;String&gt;()
    
    for (number in from..to)
      result.add(playSingleNumber(number))
    
    return  result
  }

  private fun playSingleNumber(number: Int): String {
  
    if (number % 5 == 0 &amp;&amp; number % 3 == 0)
      return &quot;fizz buzz&quot;
    
    if (number % 5 == 0)
      return &quot;buzz&quot;
    
    if (number % 3 == 0)
      return &quot;fizz&quot;
  
    return number.toString()
  }
}
</code></pre>
<p>The above signature of the <code>play</code> method leads to the following code when playing with the numbers between 1 and 100.</p>
<pre><code class="language-kotlin">class App {

  fun main() {
  
    val fizzBuzz = FizzBuzz()
    val result = fizzBuzz.play(1, 100)        
  }
}
</code></pre>
<p>Now the <code>main</code> method is more readable. The for-loop has not disappeared, it just moved from <code>App</code> to <code>FizzBuzz</code>.<br />
However, such a shift becomes remarkable if applied to a codebase with many classes:</p>
<ul>
<li>In the first approach, the for-cycle is repeated every time a piece of code interacts with <code>FizzBuzz</code>. In the second
approach, we are guaranteed the for-cycle is written only once: inside <code>FizzBuzz</code>.</li>
<li>If <code>main</code> interacted with 4 classes each one using the first approach of <code>FizzBuzz</code>, <code>main</code> would contain 4 for-loops.
If the 4 classes were to use the second approach, <code>main</code> will contain zero for-loops.</li>
</ul>
<p>To summarise with a catchphrase from John Ousterhout, classes should be narrow and deep:</p>
<ul>
<li>narrow means few public methods with few input parameters</li>
<li>deep means public methods get a lot of things done for the caller</li>
</ul>
<br/>  
<h4><a class="header" href="#recommended-reads-13" id="recommended-reads-13">Recommended reads</a></h4>
<ul>
<li><a href="https://lwn.net/Articles/193245/">&quot;Bad programmers worry about the code. Good programmers worry about data structures and their relationships&quot; - Linus Torvalds</a></li>
<li><a href="https://www.goodreads.com/book/show/13629.The_Mythical_Man_Month">&quot;Show me your tables, and I won't usually need your flowcharts; they'll be obvious.&quot;, chapter 9 of The Mythical Man-Month - Fred Brooks</a></li>
<li><a href="https://www.goodreads.com/en/book/show/39996759-a-philosophy-of-software-design">ava and Unix I/O, section 4.7 of A Philosophy of Software Design - John Ousterhout</a></li>
<li><a href="https://www.goodreads.com/book/show/4268826-growing-object-oriented-software-guided-by-tests">A web of objects, chapter 2 of Growing Object-Oriented Software, Guided by Tests - Steve Freeman, Nat Pryce</a></li>
<li><a href="https://www.goodreads.com/book/show/31183020-99-bottles-of-oop">Choosing Names, section 2.8 of 99 bottles of OOP - Sandy Metz</a></li>
<li><a href="https://www.goodreads.com/book/show/18043011-clean-architecture">The interface segregation principle, chapter 10 of Clean Architecture - Robert C. Martin</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-15" id="teach-me-back-15">Teach me back</a></h4>
<p>I really appreciate any <a href="expresses-intent/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#immutability" id="immutability">Immutability</a></h2>
<p>Understanding a piece of code is harder if objects can change their state. Let's take a look at the following example.</p>
<pre><code class="language-kotlin">enum class LightBulbState {
  ON {
    override fun lightUp(): String = &quot;bright&quot;
  },
  OFF {
    override fun lightUp(): String = &quot;dark&quot;
  };

  abstract fun lightUp(): String
}

class LightBulb(private var state: LightBulbState) {

  fun lightUp(): String {
    return state.lightUp()
  }

  fun setState(newLightBulbState: LightBulbState) {
    state = newLightBulbState
  }
}

class Room {
  private val lightBulb: LightBulb

  constructor(lightBulb: LightBulb) {
    lightBulb.setState(LightBulbState.OFF)
    this.lightBulb = lightBulb
  }
}

class App {

  fun main() {
    val lightBulb = LightBulb(LightBulbState.ON)
    val room = Room(lightBulb)

    val result = &quot;The room is ${lightBulb.lightUp()}&quot;
  }
}
</code></pre>
<p>Just looking at the <code>main</code> method of <code>App</code>, we would expect <code>result</code> to be <code>The room is bright</code>. However, because of the
<code>Room</code> constructor, the actual content of <code>result</code> is <code>The room is dark</code>. To avoid this bad surprise, <code>LightBulb</code> can become 
immutable, meaning its state cannot be modified. Let's take a look how we can achieve this.</p>
<pre><code class="language-kotlin">enum class LightBulbState {
    ON {
        override fun lightUp(): String = &quot;bright&quot;
    },
    OFF {
        override fun lightUp(): String = &quot;dark&quot;
    };

    abstract fun lightUp(): String
}

class LightBulb(private val state: LightBulbState) {

  fun lightUp(): String {
    return state.lightUp()
  }

  fun setState(newLightBulbState: LightBulbState): LightBulb {
    return LightBulb(newLightBulbState)
  }
}

class Room {
  private val lightBulb: LightBulb

  constructor(lightBulb: LightBulb) {
    this.lightBulb = lightBulb.setState(LightBulbState.OFF)
  }
}

class App {

  fun main() {
    val lightBulb = LightBulb(LightBulbState.ON)
    val room = Room(lightBulb)

    val result = &quot;The room is ${lightBulb.lightUp()}&quot;
  }
}

App().main()
</code></pre>
<p>The above code differs from the original one for three aspects:</p>
<ul>
<li>The <code>setState</code> method of <code>LightBulb</code> does not modify its state, instead it returns a brand-new instance of <code>LightBulb</code></li>
<li>The constructor of <code>Room</code> stores the brand-new <code>LightBulb</code> returned by the invocation of <code>setState</code>, instead of the <code>LightBulb</code> passed as a constructor parameter</li>
<li>The <code>LightBulb</code> constructor uses <code>val</code> instead of <code>var</code> (in Kotlin a variable defined as <code>val</code> cannot be re-assigned)</li>
</ul>
<p>Now the content of result in the <code>main</code> method of <code>App</code> is what we would expect from the beginning: <code>The room is bright</code>.
Immutability makes it easier to reason about a piece of code and it is a game changer when <a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)">concurrency</a>
comes into play. To obtain immutability we need to:</p>
<ul>
<li>return a new instance of an object instead of modifying its state</li>
<li>prevent the re-assignment of variables</li>
</ul>
<p>Unfortunately it can be tricky to write immutable code. Let's take a look at the following piece of example.</p>
<pre><code class="language-kotlin">class Shelf(private val books: List&lt;String&gt;) {

  fun numberOfBooks(): Int {
    return books.size
  }
}

class App {

  fun main() {
    val books = mutableListOf(&quot;The Secret Adversary&quot;, &quot;The Big Four&quot;)
    val shelf = Shelf(books)

    books.add(&quot;Giant's Bread&quot;)

    val result = &quot;The shelf contains ${shelf.numberOfBooks()} books&quot;
  }
}
</code></pre>
<p>The content of <code>result</code> in the <code>main</code> method of <code>App</code> will be <code>The shelf contains 3 books</code>. In fact, even if <code>Shelf</code> uses
<code>val</code> and does not allow its state to change, the <code>books</code> list can still be modified by code outside <code>Shelf</code>. For <code>Shelf</code>
to be immutable, it has to make a local copy of the <code>books</code> list received in the constructor as follows.</p>
<pre><code class="language-kotlin">class Shelf {
  private val books: List&lt;String&gt;

  constructor(booksForShelf: List&lt;String&gt;) {
    books = booksForShelf.toList() // toList makes an exact copy
  }

  fun numberOfBooks(): Int {
    return books.size
  }
}

class App {

  fun main() {
    val books = mutableListOf(&quot;The Secret Adversary&quot;, &quot;The Big Four&quot;)
    val shelf = Shelf(books)

    books.add(&quot;Giant's Bread&quot;)

    val result = &quot;The shelf contains ${shelf.numberOfBooks()} books&quot;
  }
}
</code></pre>
<p>The content of <code>result</code> in the <code>main</code> method of <code>App</code> is now <code>The shelf contains 2 books</code>.</p>
<p>As a final note, reasoning about state is hard and that's why it is worth deepen the paradigm of functional programming
which removes the concept of state as much as possible. </p>
<br/>
<h4><a class="header" href="#recommended-reads-14" id="recommended-reads-14">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/31183020-99-bottles-of-oop">Appreciating Immutability, section 5.3 of 99 bottles of OOP - Sandy Metz</a></li>
<li><a href="https://www.goodreads.com/book/show/34927404-effective-java">Make defensive copies when needed, chapter 9 of Effective Java second edition - Joshua Bloch</a></li>
<li><a href="https://leanpub.com/pfp-scala">Practical Function Programming in Scala - Gabriel Volpe</a></li>
<li><a href="https://www.goodreads.com/book/show/34921689-domain-modeling-made-functional">Domain Modeling Made Functional - Scott Wlaschin</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-16" id="teach-me-back-16">Teach me back</a></h4>
<p>I really appreciate any <a href="expresses-intent/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#generalise-edge-cases" id="generalise-edge-cases">Generalise edge cases</a></h2>
<p>Generalising edge cases makes code easier to understand as we have a single implementation to reason on. Let's assume
we need to implement the following specifications for an airport check-in application:</p>
<ul>
<li>Verify a passenger passport has not expired</li>
<li>If the passenger is a minor, verify that the accompanying parent passport has not expired</li>
</ul>
<pre><code class="language-kotlin">class CheckIn(private val today: LocalDate) {

  fun checkPassport(passport: Passport): Boolean {
    return passport.isValid(today)
  }

  fun checkMinorPassport(minorPpassport: MinorPassport):Boolean {
    return minorPpassport.isValid(today)
  }
}

class Passport(private val name: String,
               private val lastName: String,
               private val expirationDate: LocalDate) {

  fun isValid(today: LocalDate): Boolean {
    return expirationDate.isBefore(today)
  }
}

class MinorPassport(private val name: String,
                    private val lastName: String,
                    private val expirationDate: LocalDate,
                    private val parentPassport: Passport) {

  fun isValid(today: LocalDate): Boolean {
    return expirationDate.isBefore(today) &amp;&amp; parentPassport.isValid(today)
  }
}
</code></pre>
<p>The above <code>CheckIn</code> class can be simplified by generalising <code>MinorPassport</code> to <code>Passport</code> like follows.</p>
<pre><code class="language-kotlin">class CheckIn(private val today: LocalDate) {

  fun checkPassport(passport: Passport): Boolean {
    return passport.isValid(today)
  }
}

open class Passport(private val name: String,
                    private val lastName: String,
                    private val expirationDate: LocalDate) {

  open fun isValid(today: LocalDate): Boolean {
    return expirationDate.isBefore(today)
  }
}

class MinorPassport(private val name: String,
                    private val lastName: String,
                    private val expirationDate: LocalDate,
                    private val parentPassport: Passport) : Passport(name, lastName, expirationDate) {

  override fun isValid(today: LocalDate): Boolean {
      // The keyword super is used to invoke the isValid method of Passport
      return super.isValid(today) &amp;&amp; parentPassport.isValid(today) 
  }
}
</code></pre>
<p>(In Kotlin you need to mark a class or a method with the keyword <code>open</code> if you want to extend it)</p>
<p>The above code differs from the original one for three aspects:</p>
<ul>
<li><code>MinorPassport</code> extends <code>Passport</code></li>
<li><code>MinorPassport</code> overrides the method <code>isValid</code> of <code>Passport</code>, checking the parent passport expiration date too</li>
<li><code>CheckIn</code> exposes a single <code>checkPassport</code> method that can be used for both adults and minors passports</li>
</ul>
<p>Now the <code>CheckIn</code> class is easier to understand as it only deals with checking a passport. Furthermore, we removed 
knowledge duplication in <code>MinorPassport</code>.</p>
<p>Inheritance is not the only way to generalise edge cases. Another common approach is to use a collection 
instead of handling multiple scenarios that only differ by the occurrences of something.</p>
<br/>  
<h4><a class="header" href="#recommended-reads-15" id="recommended-reads-15">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/31183020-99-bottles-of-oop">Following the Flocking Rules, chapter 3.6 of 99 bottles of OOP - Sandy Metz</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-17" id="teach-me-back-17">Teach me back</a></h4>
<p>I really appreciate any <a href="expresses-intent/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#small-classes-and-short-methods" id="small-classes-and-short-methods">Small classes and short methods</a></h2>
<p>Mention that this also applies with tests.<br />
Mention that local variables can sometimes hinder readability</p>
<h4><a class="header" href="#recommended-reads-16" id="recommended-reads-16">Recommended reads</a></h4>
<p><a href="https://blog.codinghorror.com/curlys-law-do-one-thing/">Curly's Law: Do One Thing - Jeff Atwood</a></p>
<h2><a class="header" href="#usually-composition-is-better-than-inheritance" id="usually-composition-is-better-than-inheritance">Usually composition is better than inheritance</a></h2>
<p>Inheritance and composition are both useful to share behaviour or state from one class to another.
However, inheritance comes with a bigger burden than composition. Let's clarify this with the following example.</p>
<pre><code class="language-kotlin">open class Person(private val name: String) {
    fun name(): String {
        return &quot;My name is $name&quot;
    }
}

class Teacher(name: String) : Person(name)
class Student(name: String) : Person(name)

fun main() {
   println(Teacher(&quot;Lidia&quot;).name())   // My name is Lidia 
   println(Student(&quot;Cosimo&quot;).name())  // My name is Cosimo
}

</code></pre>
<p>So far so good, inheritance is making the method <code>name</code> reusable instead of having it duplicated in <code>Teacher</code> and <code>Student</code>.
However, let's assume we want to specify a minimum hourly wage for each Person:</p>
<pre><code class="language-kotlin">import java.math.BigDecimal

open class Person(private val name: String) {
    fun name(): String {
        return &quot;My name is $name&quot;
    }
    open fun minHourlyWageInEur(): BigDecimal {
        return BigDecimal(10)
    }
}

class Teacher(name: String) : Person(name) 

class Student(name: String) : Person(name) {
    override fun minHourlyWageInEur(): BigDecimal {
        throw Exception(&quot;Students do not have a wage&quot;)
    }
}

fun main() {
    println(Teacher(&quot;Lidia&quot;).minHourlyWageInEur())  // 10
    println(Student(&quot;Cosimo&quot;).minHourlyWageInEur()) // throws an exception
}
</code></pre>
<p>You can see above that the method <code>minHourlyWageInEur</code> is a problem for <code>Student</code> as it is not supposed to have a wage.
That's why we are forced to override it to throw an Exception in case it is invoked by mistake.
Ideally, we would like to avoid for <code>Student</code> to implement <code>minHourlyWageInEur</code>, but because of inheritance, we are stuck with it.</p>
<p>Let's see instead how things would look like if we were to use composition:</p>
<pre><code class="language-kotlin">import java.math.BigDecimal

class Person(private val name: String) {
    fun name(): String {
        return &quot;My name is $name&quot;
    }
    fun minHourlyWageInEur(): BigDecimal {
        return BigDecimal(10)
    }
}

class Teacher(private val person: Person) {
    fun name(): String {
        return &quot;My name is $person.name()&quot;
    }
    fun minHourlyWageInEur(): BigDecimal {
        return person.minHourlyWageInEur()
    }
}

class Student(private val person: Person) {
    fun name(): String {
        return person.name()
    }
}

fun main() {
    println(Teacher(Person(&quot;Lidia&quot;)).minHourlyWageInEur())  // 10
    println(Student(Person(&quot;Cosimo&quot;)).name())               // My name is Cosimo
}
</code></pre>
<p>We are still reusing the method <code>name</code> defined in <code>Person</code>, but we do not have the burden to support all the public methods 
of <code>Person</code>, among which the problematic <code>minHourlyWageInEur</code> for <code>Student</code>.</p>
<p>Inheritance is especially problematic if we extend classes that we do not control. For instance, when they are maintained 
by a different team or even worse when they are part of an external library. We will be forced to handle any future change on the
public methods of the class we inherited from.</p>
<p>Be mindful that inheritance is not intrinsically bad. Like any other tool it is just the way we use it which can be troublesome.
Despite inheritance usually being not great to share state or behaviour across classes, it is very useful to establish <a href="https://en.wikipedia.org/wiki/Is-a">is-a</a> 
relationships which is one way to leverage <a href="expresses-intent/../does-not-repeat-itself/polymorphism.html">polymorphism</a></p>
<h4><a class="header" href="#recommended-reads-17" id="recommended-reads-17">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/56083609-head-first-design-patterns">Decorating Objects, chapter 3 of Head First Design Patterns - Eric Freeman, Elizabeth Robson</a></li>
<li><a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">&quot;Duplication is far cheaper than the wrong abstraction&quot;, RailsConf 2014, all the little things talk - Sandy Metz</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-18" id="teach-me-back-18">Teach me back</a></h4>
<p>I really appreciate any <a href="expresses-intent/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#test-naming" id="test-naming">Test naming</a></h2>
<ul>
<li>Mention [1] Characterization tests, chapter 13 of Working Effectively with Legacy Code - Michael Feathers</li>
<li>Mention &quot;should&quot; keyword</li>
<li>Mention multiple assertions</li>
<li>Make a case against generic terms like &quot;correct&quot; in favour of specificity</li>
</ul>
<h2><a class="header" href="#comment-the-why" id="comment-the-why">Comment the why</a></h2>
<br/>  
<h4><a class="header" href="#recommended-reads-18" id="recommended-reads-18">Recommended reads</a></h4>
<ul>
<li><a href="https://youtu.be/ZsHMHukIlJY?t=633">Seven Ineffective Coding Habits of Many Programmers, Kevlin Henney</a></li>
<li><a href="https://www.goodreads.com/book/show/3735293-clean-code">Comments, chapter 4 of Clean Code - Robert C. Martin</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-19" id="teach-me-back-19">Teach me back</a></h4>
<p>I really appreciate any <a href="expresses-intent/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#visual-indentation" id="visual-indentation">Visual indentation</a></h2>
<p>Mention that visual spacing sometimes suggests refactoring (e.g.extract responsibilities, separating concerns)</p>
<br/>  
<h4><a class="header" href="#recommended-reads-19" id="recommended-reads-19">Recommended reads</a></h4>
<ul>
<li><a href="https://youtu.be/ZsHMHukIlJY?t=633">Seven Ineffective Coding Habits of Many Programmers, Kevlin Henney</a></li>
<li><a href="https://www.goodreads.com/book/show/3735293-clean-code">Formatting, chapter 5 of Clean Code - Robert C. Martin</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-20" id="teach-me-back-20">Teach me back</a></h4>
<p>I really appreciate any <a href="expresses-intent/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#folder-structure" id="folder-structure">Folder structure</a></h2>
<br/>
<h4><a class="header" href="#recommended-reads-20" id="recommended-reads-20">Recommended reads</a></h4>
<ul>
<li><a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">The onion architecture - Jeffrey Palermo</a></li>
<li><a href="https://youtu.be/5FtFnBn_dew">The onion architecture - Matteo Di Tucci</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-21" id="teach-me-back-21">Teach me back</a></h4>
<p>I really appreciate any <a href="expresses-intent/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#wishful-thinking" id="wishful-thinking">Wishful thinking</a></h2>
<p>Here mention the practice of sketching public methods to start reasoning about design before implementing the functionality.<br />
Explain how this can be applied in both trunk based and branch based development.</p>
<h1><a class="header" href="#it-does-not-repeat-itself" id="it-does-not-repeat-itself">It does not repeat itself</a></h1>
<p>Complexity is made of two elements: cognitive load and coupling. Cognitive load means how hard is to understand code. 
Coupling means how many parts of a codebase we need to adjust when we want to change only one thing.</p>
<p>Isolating concepts in single parts of the code base greatly reduces both cognitive load and coupling.</p>
<h2><a class="header" href="#one-single-authoritative-knowledge-representation" id="one-single-authoritative-knowledge-representation">One single authoritative knowledge representation</a></h2>
<p>Duplicated knowledge is harmful because it makes changes expensive. Worse than that, it conceals the code intent.
Let's take a look at the following code.</p>
<pre><code class="language-kotlin">class Person(private val name: String) {

  fun name(): String {
    return name
  }
}

class Job(private val name:String) {

  fun name(): String {
    return name
  }
}

class App {

  fun main() {
    val person = Person(&quot;Andrea&quot;)
    val job = Job(&quot;developer&quot;)

    val result = person.name() + &quot; is a &quot; + job.name() //Andrea is a developer
  }
}
</code></pre>
<p>Now let's assume we want to have an ellipsis when <code>Person</code> or <code>Job</code> names are longer than 5 characters. One solution
could be to modify the <code>name</code> method of both <code>Person</code> and <code>Job</code> like follows.</p>
<pre><code class="language-kotlin">class Person(private val name: String) {

  fun name(): String {
    if (name.length &gt; 5) {
      return name.substring(0, 5) + &quot;...&quot;
    }
    return name
  }
}

class Job(private val name:String) {

  fun name(): String {
    if (name.length &gt; 5) {
      return name.substring(0, 5) + &quot;...&quot;
    }
    return name
  }
}

class App {

  fun main() {
    val person = Person(&quot;Andrea&quot;)
    val job = Job(&quot;developer&quot;)

    val result = person.name() + &quot; is a &quot; + job.name() //Andre... is a devel...
  }
}
</code></pre>
<p>In the above code, changing the ellipsis threshold from 5 to 10 characters will affect the <code>name</code> method of both <code>Person</code>and <code>Job</code> classes.
Moreover, there is a risk to introduce bugs as changes might not be replicated across both classes by mistake. The problem
is that the concept of name is spread across <code>Person</code> and <code>Job</code> instead if being a standalone class like follows.</p>
<pre><code class="language-kotlin">class Name(private val name: String) {

  fun format(): String {
    if (name.length &gt; 5) {
      return name.substring(0, 5) + &quot;...&quot;
    }
    return name
  }
}

class Person(private val name: Name) {

  fun format(): String {
    return name.format()
  }
}

class Job(private val name:Name) {

  fun format(): String {
    return name.format()
  }
}

class App {

  fun main() {
    val person = Person(Name(&quot;Andrea&quot;))
    val job = Job(Name(&quot;developer&quot;))

    val result = person.format() + &quot; is a &quot; + job.format() //Andre... is a devel...
  }
}
</code></pre>
<p>Now the intent is clearer, making it easier to reason about the code. Furthermore, whenever we need to change something
related to the concept of name, only the <code>Name</code> class will be affected.</p>
<p>As a final note, be mindful that knowledge duplication might be there even if the code looks different. The typical example
is <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">object-relational mapping libraries</a> and SQL
initialisation scripts: who of the two is responsible for the knowledge of database tables creation?</p>
<br/>  
<h4><a class="header" href="#recommended-reads-21" id="recommended-reads-21">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/4099.The_Pragmatic_Programmer">DRY, The evils of duplication, chapter 2 of The Pragmatic Programmer - David Thomas, Andrew Hunt</a></li>
<li><a href="https://www.goodreads.com/book/show/67833.Extreme_Programming_Explained">Once and only once, Extreme Programming Explained - Kent Beck</a></li>
<li><a href="https://www.goodreads.com/book/show/7003902-97-things-every-programmer-should-know">Don't Repeat Yourself, chapter 30 of 97 Things Every Programmer Should Know - Kevlin Henney</a></li>
<li><a href="https://www.goodreads.com/book/show/18043011-clean-architecture">The Liskov substitution principle, chapter 9 of Clean Architecture - Robert C. Martin</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-22" id="teach-me-back-22">Teach me back</a></h4>
<p>I really appreciate any <a href="does-not-repeat-itself/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#do-not-abstract-by-visual-pattern-matching" id="do-not-abstract-by-visual-pattern-matching">Do not abstract by visual pattern matching</a></h2>
<p>Two pieces of code that are identical but represent two distinct concepts should stay separated: they are not duplication.
Let's consider the example where we are asked to calculate the perimeter of rectangles and rhombuses.</p>
<pre><code class="language-kotlin">class Rhombus(private val width: Int, private val height: Int) {

  fun perimeter(): Int {
    return 2 * (width + height)
  }
}

class Rectangle(private val width: Int, private val height: Int) {

  fun perimeter(): Int {
    return 2 * (width + height)
  }
}
</code></pre>
<p>When seeing a piece of code like the above, one might be tempted to remove the duplication of the <code>perimeter</code> method like follows.</p>
<pre><code class="language-kotlin">class Shape(private val width: Int, private val height: Int) {

  fun perimeter(): Int {
    return 2 * (width + height)
  }
}
</code></pre>
<p>However, what happens if after some time we are asked to calculate the perimeter of a circle? Now the concept represented
by <code>Shape</code> does not relate to circle, which is definitely a shape though. There are many ways to refactor this situation,
for instance making shape an interface, but in a large codebase these refactorings are more expensive than leaving duplicated code
until we understand it is duplicated knowledge. It is hard to build the right knowledge model, especially if specifications
are not entirely known or the domain is complex. In doubt, the rule of thumb is to remove duplication only after it occurs
more than two times.</p>
<br/>  
<h4><a class="header" href="#recommended-reads-22" id="recommended-reads-22">Recommended reads</a></h4>
<ul>
<li><a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">&quot;Duplication is far cheaper than the wrong abstraction&quot;, RailsConf 2014, all the little things talk - Sandy Metz</a></li>
<li><a href="https://www.goodreads.com/en/book/show/44936.Refactoring">Rule of three, When we should Refactor? chapter 2 of Refactoring - Martin Fowler</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-23" id="teach-me-back-23">Teach me back</a></h4>
<p>I really appreciate any <a href="does-not-repeat-itself/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#open-closed-principle" id="open-closed-principle">Open-closed principle</a></h2>
<p>A good sign of low knowledge duplication is the creation of new classes instead of modifying existing ones when we implement 
new specifications. To give an example, let's assume we need to implement the following:</p>
<ul>
<li>A light bulb that returns the message &quot;I am shining&quot;</li>
</ul>
<pre><code class="language-kotlin">class LightBulb {

  fun lightUp(): String {
    return &quot;I am shining&quot;
  }
}
</code></pre>
<p>So far so good. Now let's assume we receive further specifications:</p>
<ul>
<li>A light bulb that returns the message &quot;I am shining&quot; if it is on</li>
<li>A light bulb that returns the message &quot;I am dark&quot; if it is off</li>
</ul>
<p>It does not seem a big deal, so we could proceed modifying the existing <code>LightBulb</code> class like the following:</p>
<pre><code class="language-kotlin">enum class LightBulbState {
  ON,
  OFF
}

class LightBulb(private val state: LightBulbState) {

  fun lightUp(): String {
    if (state == LightBulbState.ON) {
      return &quot;I am shining&quot;
    }
    return &quot;I am dark&quot;
  }
}
</code></pre>
<p>Let's now implement one last specification:</p>
<ul>
<li>A light bulb that returns the message &quot;I am broken&quot; if it is broken</li>
</ul>
<p>If we insist modifying the <code>LightBulb</code> class we end up like the following:</p>
<pre><code class="language-kotlin">enum class LightBulbState {
  ON,
  OFF,
  BROKEN
}

class LightBulb(private val state: LightBulbState) {

  fun lightUp(): String {
    if (state == LightBulbState.ON) {
      return &quot;I am shining&quot;
    }
    if (state == LightBulbState.OFF) {
      return &quot;I am dark&quot;
    }
    return &quot;I am broken&quot;
  }
}
</code></pre>
<p>If this trend of specifications continues, we will end up having a very long <code>lightUp</code> method and many unit tests just 
for it. The result will be <code>LightBulb</code> not clearly expressing its intent as well as being a hot spot containing too much
knowledge. To prevent this we can spread the <code>lightUp</code> knowledge across the different values of <code>LightBulbState</code>
like follows.</p>
<pre><code class="language-kotlin">enum class LightBulbState {
  ON {
      override fun lightUp(): String {
          return &quot;I am shining&quot;
      }
  },
  OFF {
      override fun lightUp(): String {
          return &quot;I am dark&quot;
      }
  },
  BROKEN {
      override fun lightUp(): String {
          return &quot;I am broken&quot;
      }
  };

    abstract fun lightUp(): String
}

class LightBulb(private val state: LightBulbState) {

  fun lightUp(): String {
      return state.lightUp()
  }
}
</code></pre>
<p>Now each <code>LightBulbState</code> is responsible for its bit of <code>lightUp</code> knowledge while the <code>LightBulb</code> class remains short and clear to understand.
This means the following specification can be implemented by adding another <code>LightBulbState</code>, without modifying <code>LightBulb</code>:</p>
<ul>
<li>A light bulb that returns the message &quot;I am shining softly&quot; if it is dimmed.</li>
</ul>
<pre><code class="language-kotlin">enum class LightBulbState {
  ON {
      override fun lightUp(): String {
          return &quot;I am shining&quot;
      }
  },
  OFF {
      override fun lightUp(): String {
          return &quot;I am dark&quot;
      }
  },
  BROKEN {
      override fun lightUp(): String {
          return &quot;I am broken&quot;
      }
  },
  DIMMED {
      override fun lightUp(): String {
          return &quot;I am shining softly&quot;
      }
  };

    abstract fun lightUp(): String
}

class LightBulb(private val state: LightBulbState) {

  fun lightUp(): String {
      return state.lightUp()
  }
}
</code></pre>
<br/>
<h4><a class="header" href="#recommended-reads-23" id="recommended-reads-23">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/31183020-99-bottles-of-oop">Starting With the Open/Closed Principle, chapter 3.2 of 99 bottles of OOP - Sandy Metz</a></li>
<li><a href="https://www.goodreads.com/book/show/84985.Agile_Software_Development_Principles_Patterns_and_Practices">OCP: The Open-Closed Principle, chapter 9 Agile Software Development, Principles, Patterns, and Practices  - Robert C. Martin</a></li>
<li><a href="https://www.goodreads.com/book/show/18043011-clean-architecture">The open-closed principle, chapter 8 of Clean Architecture - Robert C. Martin</a></li>
<li><a href="https://medium.com/geekculture/why-you-shouldnt-use-booleans-in-rest-apis-2747b187876c">Why you shouldn‚Äôt use booleans in REST APIs - Hany Elemary</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-24" id="teach-me-back-24">Teach me back</a></h4>
<p>I really appreciate any <a href="does-not-repeat-itself/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#dependency-inversion-principle" id="dependency-inversion-principle">Dependency inversion principle</a></h2>
<p>Code that changes frequently should depend on code that rarely changes. This is important to minimises the amount of code
we need to adjust when implementing new specifications. Let's take a look at the following example.</p>
<pre><code class="language-kotlin">class Transfer(private val sender: String,
               private val receiver: String,
               private val amount: Int) {

  fun save(transferFile: TransfersFile) {
    transferFile.save(sender, receiver, amount)
  }
}

class TransferFile {

    fun save(sender: String, receiver: String, amount: Int) {
        File(&quot;transfers.csv&quot;).writeText(&quot;$sender,$receiver,$amount&quot;)
    }
}

class App {

    fun main() {
        val transfer = Transfer(&quot;Andrea&quot;, &quot;Dani&quot;, 100)
        val file = TransferFile()
        transfer.save(file)
    }
}
</code></pre>
<p>In the above code, the class <code>Transfer</code> depends on <code>TransferFile</code> as the former takes the latter as input parameter
in the <code>save</code> method. Now let's assume we know that the class <code>TransferFile</code> is going to change a lot in the future, 
for instance because it might become a different class that saves <code>Transfer</code> to a database or because it will connect
to a third party api over the internet and its <code>save</code> method signature might change. Even worse, we won't be able to modify <code>TransferFile</code>
in the future as another developer is going to take care of it. In this situation, the risk is that everytime <code>TransferFile</code>
changes, we will be forced to change our <code>Transfer</code> class as well. We can prevent this by leveraging the dependency inversion
principle like in the following code.</p>
<pre><code class="language-kotlin">interface TransferStorage {
  fun save(sender: String, receiver: String, amount: Int)
}

class Transfer(private val sender: String, 
                    private val receiver: String, 
                    private val amount: Int) {

  fun save(file: TransferStorage) {
    file.save(sender, receiver, amount)
  }
}

class TransferFile : TransferStorage {

  override fun save(sender: String, receiver: String, amount: Int) {
    File(&quot;transfers.csv&quot;).writeText(&quot;$sender,$receiver,$amount&quot;)
  }
}

class App {

  fun main() {
    val transfer = Transfer(&quot;Andrea&quot;, &quot;Dani&quot;, 100)
    val file = TransferFile()

    transfer.save(file)
  }
}
</code></pre>
<p>The above code differs from the original one for three aspects:</p>
<ul>
<li>We introduced <code>TransferStorage</code> which contains an abstract definition of the method <code>save</code></li>
<li><code>Transfer</code> does not depend anymore on <code>TransferFile</code> as it now depends on <code>TransferStorage</code></li>
<li><code>TransferFile</code> now depends on <code>TransferStorage</code> as it implements its <code>save</code> method</li>
</ul>
<p>With this, we have inverted the dependency we had from <code>Transfer</code> to <code>TransfersFile</code>. In fact, <code>Transfer</code> has become unaware
of any change that might happen to <code>TransfersFile</code>. Furthermore, <code>Transfer</code> becomes in general unaware of the technology
used to store it: as far as a class implements <code>TransferStorage</code>, it can be passed to <code>Transfer</code> 
inside the <code>main</code> method of <code>App</code>. This means we could be using a new class <code>TransfersDatabase</code> and <code>Transfer</code> would not know it.
On the contrary, <code>TransfersFile</code> now depends on <code>TransferStorage</code> but that's fine as we know <code>TransferStorage</code> will rarely
change.</p>
<p>As a final note, <code>TransferStorage</code> has also become the <a href="does-not-repeat-itself/one-single-authoritative-representation.html">single authoritative representation</a>
of how to store <code>Transfer</code>.</p>
<br/>
<h4><a class="header" href="#recommended-reads-24" id="recommended-reads-24">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/31183020-99-bottles-of-oop">Depending on abstractions, chapter 4.9 of 99 bottles of OOP - Sandy Metz</a></li>
<li><a href="https://www.goodreads.com/book/show/18043011-clean-architecture">The dependency inversion principle, chapter 11 of Clean Architecture - Robert C. Martin</a></li>
<li><a href="https://www.goodreads.com/book/show/3735293-clean-code">Dependency injection, chapter 11 of Clean Code - Robert C. Martin</a></li>
<li><a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">The onion architecture - Jeffrey Palermo</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-25" id="teach-me-back-25">Teach me back</a></h4>
<p>I really appreciate any <a href="does-not-repeat-itself/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#information-hiding" id="information-hiding">Information Hiding</a></h2>
<p>When objects expose their internal implementation, modifying code becomes harder. In fact, a single change can unexpectedly 
trigger many others across the code base. Let's take a look at the following example.</p>
<pre><code class="language-kotlin">class Die {
  var value: Int = 1

  fun roll() {
    value = (1..6).random()
  }
}

class Game{

  fun play() {
    val player1Die = Die()
    val player2Die = Die()

    player1Die.roll()
    player2Die.roll()

    if(player1Die.value &gt; player2Die.value) {
      print(&quot;Player 1 wins&quot;)
      return
    }
    if(player1Die.value &lt; player2Die.value) {
      print(&quot;Player 2 wins&quot;)
      return
    }
    print(&quot;Draw&quot;)
  }
}
</code></pre>
<p>In the above code <code>Die</code> is leaking two pieces of information:</p>
<ul>
<li>The die faces are modelled as integer numbers</li>
<li>A die wins over another if the former <code>value</code> is greater than the latter</li>
</ul>
<p>If any of the above two change, we will need to adjust <code>Game</code>  as its <code>play</code> method uses that information.
An example of such changes is a new rule by which the number 3 wins over any other number.
However, we can prevent those unintended changes in <code>Game</code> by not leaking information out of <code>Die</code> as follows.</p>
<pre><code class="language-kotlin">class Die {
  private var value = 1

  fun roll() {
    value = (1..6).random()
  }

  fun winner(player2Die: Die): String {
    if(value &gt; player2Die.value) {
      return &quot;Player 1 wins&quot;
    }
    if(value &lt; player2Die.value) {
      return &quot;Player 2 wins&quot;
    }
    return &quot;Draw&quot;
  }
}

class Game{

  fun play() {
    val player1Die = Die()
    val player2Die = Die()

    print(player1Die.winner(player2Die))
  }
}
</code></pre>
<p><code>Die</code> has now become the only class knowing about how a die is made and how it wins over another. This means we are now 
free to change its internal implementation without interfering with <code>Game</code> or any other part of the codebase.</p>
<p>As a final note, leaking information can be subtle and can occur even at naming level. For instance, there is nothing
wrong in naming a class <code>InMemoryResource</code>. However, if we want to modify it to fetch the resource over the internet,
we first need to ask ourselves if other code has been written using <code>InMemoryResource</code> implicitly assuming that it guarantees high availability.</p>
<br/>
<h4><a class="header" href="#recommended-reads-25" id="recommended-reads-25">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/3735293-clean-code">Encapsulation, chapter 10 of Clean Code - Robert C. Martin</a></li>
<li><a href="https://www.goodreads.com/book/show/7003902-97-things-every-programmer-should-know">Encapsulate Behavior,Not Just State - chapter 10 of of 97 Things Every Programmer Should Know - Kevlin Henney</a></li>
<li><a href="https://www.goodreads.com/en/book/show/39996759-a-philosophy-of-software-design">Information Hiding, chapter 5 of A Philosophy of Software Design - John Ousterhout</a></li>
<li><a href="https://www.goodreads.com/book/show/4099.The_Pragmatic_Programmer">Decoupling and the Law of Demeter, chapter 5 of The Pragmatic Programmer - David Thomas, Andrew Hunt</a></li>
<li><a href="https://www.goodreads.com/book/show/4268826-growing-object-oriented-software-guided-by-tests">Hide the right information, chapter 6 of of Growing Object-Oriented Software, Guided by Tests - Steve Freeman, Nat Pryce</a></li>
<li><a href="https://williamdurand.fr/2013/06/03/object-calisthenics/">Object Calisthenics, William Durand</a></li>
<li><a href="https://michaelfeathers.typepad.com/michael_feathers_blog/2012/03/tell-above-and-ask-below-hybridizing-oo-and-functional-design.html">Tell Above, and Ask Below - Michael Feathers</a></li>
<li><a href="https://lukashajdu.com/post/majestic-modular-monolith/">Majestic Modular Monoliths - Lukas Hajdu</a></li>
<li><a href="https://shopify.engineering/deconstructing-monolith-designing-software-maximizes-developer-productivity">Deconstructing the Monolith - Kirsten Westeinde, Shopify</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-26" id="teach-me-back-26">Teach me back</a></h4>
<p>I really appreciate any <a href="does-not-repeat-itself/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#wrap-external-libraries-into-custom-classes" id="wrap-external-libraries-into-custom-classes">Wrap external libraries into custom classes</a></h2>
<p><a href="does-not-repeat-itself/../does-not-repeat-itself/information-hiding.html">Information hiding</a> also applies to external libraries. In fact,
swapping a library for another can unexpectedly
trigger many undesired changes across our codebase.</p>
<p>Let's take a look at the following code.</p>
<pre><code class="language-kotlin">class MessageController(private val metrics: MetricExternalLibrary) {

    fun handleMessage(message: String) {
        metrics.incrementMetric(&quot;total-messages-received&quot;)
    }
}

class UserController(private val metrics: MetricExternalLibrary) {

    fun handleLogin(username: String) {
        metrics.incrementMetric(&quot;total-users-logged-in&quot;)
    }
}
</code></pre>
<p>In the above code, <code>MetricExternalLibrary</code> is an external library that we use for monitoring purposes. 
The method <code>incrementMetric</code> takes in input the name of the metric to be incremented by one.
Let's assume we want to replace <code>MetricExternalLibrary</code> with another library called <code>FasterMetricExternalLibrary</code> because it has better performance. If that's the case, we would be forced to replace all the occurrences of <code>MetricExternalLibrary</code>, which in the above example are just two, but in a real life codebase can be many. </p>
<p>To prevent this we can wrap <code>MetricExternalLibrary</code> in a custom class so that it does not spread across the codebase.</p>
<pre><code class="language-kotlin">class MessageController(private val metrics: Metrics) {

    fun handleMessage(message: String) {
        metrics.incrementMetric(&quot;total-messages-received&quot;)
    }
}

class UserController(private val metrics: Metrics) {

    fun handleLogin(username: String) {
        metrics.incrementMetric(&quot;total-users-logged-in&quot;)
    }
}

class Metrics(private val metricExternalLibrary: MetricExternalLibrary) {
    fun incrementMetric(metricName: String) {
        this.metricExternalLibrary.incrementMetricOf(metricName)
    }
}
</code></pre>
<p>Now our class <code>Metrics</code> will be the only place in the codebase that knows about <code>MetricExternalLibrary</code>. Whenever we
need to replace <code>MetricExternalLibrary</code> in favour of <code>FasterMetricExternalLibrary</code>, only <code>Metrics</code> will be affected.
This ensures our codebase remains stable despite any library change we might have in the future. </p>
<p>As a final note, wrapping external libraries into custom classes will also simplify testing as explained in the
<a href="does-not-repeat-itself/../passes-all-tests/do-not-test-external-libraries.html">do not test external libraries</a> chapter.</p>
<br/>
<h4><a class="header" href="#recommended-reads-26" id="recommended-reads-26">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/58128.Head_First_Design_Patterns">Adapter pattern chapter of Head First Design Patterns - Eric Freeman, Elisabeth Robson</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-27" id="teach-me-back-27">Teach me back</a></h4>
<p>I really appreciate any <a href="does-not-repeat-itself/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current
understanding of software design.</p>
<h2><a class="header" href="#polymorphism" id="polymorphism">Polymorphism</a></h2>
<h4><a class="header" href="#recommended-reads-27" id="recommended-reads-27">Recommended reads</a></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">The 3 different kinds of polymorphism - Wikipedia</a></li>
</ul>
<h2><a class="header" href="#single-responsibility-principle" id="single-responsibility-principle">Single responsibility principle</a></h2>
<p>Mention high cohesion in the context of one reason for a class to change</p>
<h4><a class="header" href="#recommended-reads-28" id="recommended-reads-28">Recommended reads</a></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Class-responsibility-collaboration_card">Class-responsibility-collaboration card - Ward Cunningham, Kent Beck</a></li>
<li><a href="https://www.goodreads.com/book/show/18043011-clean-architecture">The single responsibility principle, chapter 7 of Clean Architecture - Robert C. Martin</a></li>
</ul>
<h1><a class="header" href="#it-does-not-contain-superfluous-parts" id="it-does-not-contain-superfluous-parts">It does not contain superfluous parts</a></h1>
<p>A problem can be solved by many solutions, but the best ones have few moving parts. Less moving part implies less to understand,
test and maintain.</p>
<p>Sometimes we write superfluous code because we misunderstand the problem. Other times we end up implementing requirements 
which were never asked because our experience or anxiety for the future biased us. Finally, even when everything is clear 
in our minds, we need to take the time to explore different designs and see what works best.</p>
<h2><a class="header" href="#you-arent-going-to-need-it" id="you-arent-going-to-need-it">You aren't going to need it</a></h2>
<p>Writing code that is beyond specifications is not only a waste of time, but it also introduces unnecessary complexity.
This complexity consists mainly in more code and tests to understand and maintain. Worse than that, superfluous code
makes it harder to change code in the future. Let's consider an example given the following specifications:</p>
<ul>
<li>Create a pedestrian traffic light allowing to walk if green, denying it if red</li>
<li>The traffic light can change color from red to green and vice versa</li>
</ul>
<pre><code class="language-kotlin">class TrafficLight(private var colour: TrafficLightColour) {

  fun changeColour() {
    colour = colour.changeColour()
  }

  fun possibleToWalk(): Boolean {
    return colour.possibleToWalk()
  }
}

enum class TrafficLightColour {
  RED {
    override fun changeColour() = GREEN
    override fun possibleToWalk() = false
  },
  GREEN {
    override fun changeColour() = RED
    override fun possibleToWalk() = true
  };

  abstract fun changeColour(): TrafficLightColour
  abstract fun possibleToWalk(): Boolean
}
</code></pre>
<p>The above code satisfies the specifications. However, one might say that traffic lights for pedestrians are usually timed: you press
a button and it will take some seconds before the colour changes. This was not requested, but as it seems to be a more
faithful representation of a pedestrian traffic light, so one might decide to go ahead like follows.</p>
<pre><code class="language-kotlin">class TrafficLight(private var colour: TrafficLightColour) {

  fun changeColour(milliSecondsToWait: Long) {
    waitFor(milliSecondsToWait)
    colour = colour.changeColour(colour)
  }

  fun possibleToWalk(): Boolean {
    return colour.possibleToWalk()
  }

  private fun waitFor(milliSecondsToWait: Long) {
    Thread.sleep(milliSecondsToWait)
  }
}

enum class TrafficLightColour {
  RED {
    override fun changeColour() = GREEN
    override fun possibleToWalk() = false
  },
  GREEN {
    override fun changeColour() = RED
    override fun possibleToWalk() = true
  };

  abstract fun changeColour(): TrafficLightColour
  abstract fun possibleToWalk(): Boolean
}
</code></pre>
<p>Changing the behaviour of <code>changeColour</code> in <code>TrafficLight</code> had no benefits for what we are concerned with the current specifications. However,
it added useless code inside the <code>TrafficLight</code> class and it forced all callers of the <code>changeColour</code> method to provide a value for
<code>milliSecondsToWait</code> which, given the current specifications, will always be 0.</p>
<br/>  
<h4><a class="header" href="#recommended-reads-29" id="recommended-reads-29">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/en/book/show/44936.Refactoring">Refactoring, Architecture, and YAGNI, chapter 2 of Refactoring - Martin Fowler</a></li>
<li><a href="https://www.goodreads.com/book/show/67833.Extreme_Programming_Explained">Chapter 17 of Extreme Programming Explained - Kent Beck</a></li>
<li><a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">Incidental vs accidental complexity, No Silver Bullet paper - Fred Brooks</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-28" id="teach-me-back-28">Teach me back</a></h4>
<p>I really appreciate any <a href="does-not-contain-superfluous-parts/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#clarify-what-is-superfluous" id="clarify-what-is-superfluous">Clarify what is superfluous</a></h2>
<p>Sometimes the <a href="does-not-contain-superfluous-parts/you-are-not-going-to-need-it.html">you aren't going to need it</a> principle is abused, leading to code that does
not pass all tests. This usually happens in the form of assuming specifications. Let's consider the following example where we are required
to build a piece of code that:</p>
<ul>
<li>stores fruits by their names</li>
<li>does not store a fruit name more than once</li>
<li>given a fruit name, returns true if it has been previously stored</li>
</ul>
<pre><code class="language-kotlin">class FruitInventory {
  private val fruits = ArrayList&lt;String&gt;()

  fun storeFruit(name: String) {
    if (contains(name))
      return
    
    fruits.add(name)
  }

  fun contains(name: String): Boolean {
    for(fruit in fruits) {
      if (name == fruit)
        return true
    }
    return false
  }
}
</code></pre>
<p>The above code works just fine given the specifications. However, we might argue that <code>fruits</code> implemented as a list
is not very performant and that we could make both <code>contains</code> and <code>storeFruit</code> faster by simply using a set.
It is a mistake to dismiss such thought appealing to the <a href="does-not-contain-superfluous-parts/you-are-not-going-to-need-it.html">you aren't going to need it</a> principle.
In fact, we would be assuming a specification about performance that is currently unknown. We should instead clarify the
expected performance of <code>FruitInventory</code>: if it is irrelevant then the code is as good as it is, otherwise we need
to change it as follows.</p>
<pre><code class="language-kotlin">class FruitInventory {
  private val fruits = HashSet&lt;String&gt;()

  fun storeFruit(name: String) {
    fruits.add(name)
  }
  
  fun contains(name: String): Boolean {
    return fruits.contains(name)
  }
}
</code></pre>
<p>Performance specifications aside, the above code using <code>HashSet</code> is superior as it better expresses intent. We could even
argue that <code>HashSet</code> approach satisfies the specifications just fine and we aren't going to need all the for-loop complexity
introduced by the <code>ArrayList</code> approach.</p>
<br/>  
<h4><a class="header" href="#recommended-reads-30" id="recommended-reads-30">Recommended reads</a></h4>
<ul>
<li><a href="https://dl.acm.org/toc/csur/1974/6/4">The full quote from Donald Knuth was: &quot;We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.&quot;</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-29" id="teach-me-back-29">Teach me back</a></h4>
<p>I really appreciate any <a href="does-not-contain-superfluous-parts/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>
<h2><a class="header" href="#do-not-abuse-design-patterns" id="do-not-abuse-design-patterns">Do not abuse design patterns</a></h2>
<p>Design patterns are great to catalogue recurring design problems and their typical solutions. However, design patterns by themselves
do not guarantee simple code, and actually they can end up pushing in the opposite direction. They are just a tool that
has to be adapted to the context where they are used, not applied to the letter.</p>
<br/>  
<h4><a class="header" href="#recommended-reads-31" id="recommended-reads-31">Recommended reads</a></h4>
<ul>
<li><a href="https://www.goodreads.com/book/show/58128.Head_First_Design_Patterns">Head First Design Patterns - Eric Freeman, Elisabeth Robson</a></li>
</ul>
<h4><a class="header" href="#teach-me-back-30" id="teach-me-back-30">Teach me back</a></h4>
<p>I really appreciate any <a href="does-not-contain-superfluous-parts/../introduction/introduction.html#teach-me-back">feedback</a> about the book and my current understanding of software design.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
